<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tango Puzzle - Backbencher Edition</title>

  <!-- Tailwind and Bootstrap -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" />
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Custom Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet" />

  <style>
    body {
      font-family: 'VT323', monospace;
      background-color: #121212;
      color: #f8f8f2;
      text-align: center;
      min-height: 100vh;
      margin: 0;
      padding-top: 64px;
      display: flex;
      flex-direction: column;
    }

    h1 {
      font-size: 2.5rem;
      color: #ffcc00;
      text-shadow: 0 0 5px #ffcc00;
      margin-top: 1rem;
    }

    #controls {
      margin: 1rem 0;
    }

    select, button {
      font-family: 'VT323', monospace;
      font-size: 1.2rem;
      padding: 6px 12px;
      background-color: #282828;
      color: #f8f8f2;
      border: 1px solid #888;
      border-radius: 4px;
      margin: 0 6px;
      cursor: pointer;
    }

    button:hover, select:hover {
      background-color: #444;
    }

    table {
      margin: 1rem auto;
      border-collapse: collapse;
      max-width: 100%;
    }

    td {
      width: 12vw;
      height: 12vw;
      max-width: 60px;
      max-height: 60px;
      border: 1px solid #888;
      font-size: 1.8rem;
      text-align: center;
      vertical-align: middle;
      position: relative;
      cursor: pointer;
      background-color: #1e1e1e;
      color: #ffeb3b;
      transition: background-color 0.2s ease;
    }

    td:hover {
      background-color: #333;
    }

    .locked {
      background-color: #333;
      color: #777;
      cursor: not-allowed;
    }

    .constraint-sign {
      position: absolute;
      font-weight: bold;
      font-size: 1.4rem;
      color: #ff4081;
      pointer-events: none;
      z-index: 2;
    }

    #message {
      font-weight: bold;
      color: #ff5252;
      margin-top: 0.8rem;
      font-size: 1.2rem;
    }

    ::selection {
      background: #ffcc00;
      color: black;
    }

    @media (max-width: 500px) {
      td {
        width: 14vw;
        height: 14vw;
        font-size: 1.4rem;
      }
    }
  </style>
</head>
<body class="overflow-x-hidden">

  <!-- Header Placeholder -->
  <div id="header-placeholder"></div>

  <main class="flex-grow px-3">
    <h1>ðŸŽ® Tango Puzzle - Backbencher Edition</h1>

    <div id="controls">
      <label for="difficulty">Difficulty:
        <select id="difficulty">
          <option value="easy">Easy</option>
          <option value="medium" selected>Medium</option>
          <option value="hard">Hard</option>
        </select>
      </label>
      <button id="resetButton">Reset</button>
      <button onclick="showRules()">Rules</button>
    </div>

    <div class="overflow-auto">
      <table id="board"></table>
    </div>

    <div id="message"></div>
  </main>

  <!-- Footer Placeholder -->
  <div id="footer-placeholder"></div>

  <!-- Load header & footer dynamically -->
  <script>
    function loadWithScripts(url, targetId) {
      fetch(url)
        .then(res => res.text())
        .then(html => {
          const wrapper = document.createElement('div');
          wrapper.innerHTML = html;

          const scripts = wrapper.querySelectorAll("script");
          scripts.forEach(oldScript => {
            const newScript = document.createElement("script");
            if (oldScript.src) newScript.src = oldScript.src;
            else newScript.textContent = oldScript.textContent;
            document.body.appendChild(newScript);
          });

          document.getElementById(targetId).innerHTML = wrapper.innerHTML;
        });
    }

    document.addEventListener("DOMContentLoaded", () => {
      loadWithScripts('../partials/header.html', 'header-placeholder');
      loadWithScripts('../partials/footer.html', 'footer-placeholder');
    });
  </script>
  <script>
    const SIZE = 6;
    const symbols = [' ', 'â—¯', 'â˜½'];
    let board = Array.from({ length: SIZE }, () => Array(SIZE).fill(0));
    let solution = [];
    let constraints = Array.from({ length: SIZE }, () => Array(SIZE).fill(null));
    const table = document.getElementById('board');
    const messageDiv = document.getElementById('message');

    const DifficultyLevels = {
      easy: { constraints: 15, prefill: 8 },
      medium: { constraints: 10, prefill: 6 },
      hard: { constraints: 5, prefill: 5 }
    };
    let currentDifficulty = 'medium';

    document.getElementById('difficulty').onchange = e => {
      currentDifficulty = e.target.value;
      generateGame();
    };

    document.getElementById('resetButton').onclick = () => {
      resetUserEntries();
    };

    window.onload = () => {
      generateGame();
    };

    function generateGame() {
      generateValidBoard();
      applyPrefillAndConstraints();
    }

    function generateValidBoard() {
      solution = Array.from({ length: SIZE }, () => Array(SIZE).fill(0));

      function isValid(r, c, val) {
        solution[r][c] = val;

        const row = solution[r];
        const col = solution.map(row => row[c]);

        if (row.filter(v => v === val).length > SIZE / 2) return false;
        if (col.filter(v => v === val).length > SIZE / 2) return false;

        for (let i = 0; i < SIZE - 2; i++) {
          if (row[i] && row[i] === row[i + 1] && row[i + 1] === row[i + 2]) return false;
          if (col[i] && col[i] === col[i + 1] && col[i + 1] === col[i + 2]) return false;
        }

        return true;
      }

      function backtrack(r = 0, c = 0) {
        if (r === SIZE) return true;

        const [nr, nc] = c === SIZE - 1 ? [r + 1, 0] : [r, c + 1];
        const vals = [1, 2];
        shuffle(vals);

        for (let v of vals) {
          if (isValid(r, c, v)) {
            solution[r][c] = v;
            if (backtrack(nr, nc)) return true;
          }
        }

        solution[r][c] = 0;
        return false;
      }

      backtrack();
    }

    function applyPrefillAndConstraints() {
      board = solution.map(row => row.slice());
      table.innerHTML = '';
      document.querySelectorAll('.constraint-sign').forEach(e => e.remove());
      constraints = Array.from({ length: SIZE }, () => Array(SIZE).fill(null));
      messageDiv.textContent = '';

      for (let r = 0; r < SIZE; r++) {
        const rowEl = document.createElement('tr');
        for (let c = 0; c < SIZE; c++) {
          const cell = document.createElement('td');
          cell.dataset.row = r;
          cell.dataset.col = c;
          cell.onclick = () => {
            if (!cell.classList.contains('locked')) {
              board[r][c] = (board[r][c] + 1) % 3;
              cell.textContent = symbols[board[r][c]];
              checkBoard();
            }
          };
          rowEl.appendChild(cell);
        }
        table.appendChild(rowEl);
      }

      const allCells = [];
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          allCells.push([r, c]);
        }
      }
      shuffle(allCells);
      const prefill = DifficultyLevels[currentDifficulty].prefill;
      const keepSet = new Set(allCells.slice(0, prefill).map(([r, c]) => `${r},${c}`));

      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          const cell = table.rows[r].cells[c];
          if (keepSet.has(`${r},${c}`)) {
            cell.textContent = symbols[board[r][c]];
            cell.classList.add('locked');
          } else {
            board[r][c] = 0;
            cell.textContent = '';
            cell.classList.remove('locked');
          }
        }
      }

      addRandomConstraints(DifficultyLevels[currentDifficulty].constraints);
    }

    function addRandomConstraints(count) {
      let added = 0;
      while (added < count) {
        const r = Math.floor(Math.random() * SIZE);
        const c = Math.floor(Math.random() * SIZE);
        const dir = Math.random() < 0.5 ? 'right' : 'down';
        let r2 = r, c2 = c;

        if (dir === 'right' && c < SIZE - 1) c2++;
        else if (dir === 'down' && r < SIZE - 1) r2++;
        else continue;

        if (constraints[r][c]) continue;

        const a = solution[r][c];
        const b = solution[r2][c2];
        const type = a === b ? '=' : 'â‰ ';

        constraints[r][c] = { type, r2, c2 };
        drawConstraint(r, c, r2, c2, type);
        added++;
      }
    }

    function drawConstraint(r1, c1, r2, c2, type) {
      const cell1 = table.rows[r1].cells[c1];
      const cell2 = table.rows[r2].cells[c2];
      const sign = document.createElement('div');
      sign.textContent = type;
      sign.className = 'constraint-sign';

      const midX = (cell1.offsetLeft + cell2.offsetLeft + cell1.offsetWidth) / 2;
      const midY = (cell1.offsetTop + cell2.offsetTop + cell1.offsetHeight) / 2;

      sign.style.left = `${midX}px`;
      sign.style.top = `${midY}px`;
      sign.style.transform = 'translate(-50%, -50%)';
      table.parentElement.appendChild(sign);
    }

    function checkBoard() {
      messageDiv.textContent = '';

      for (let i = 0; i < SIZE; i++) {
        const row = board[i];
        const col = board.map(r => r[i]);

        if (!isBalanced(row) || hasTriple(row)) {
          messageDiv.textContent = `Invalid row ${i + 1}`;
          return;
        }

        if (!isBalanced(col) || hasTriple(col)) {
          messageDiv.textContent = `Invalid column ${i + 1}`;
          return;
        }
      }

      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          const con = constraints[r][c];
          if (con) {
            const a = board[r][c];
            const b = board[con.r2][con.c2];
            if (a && b) {
              if ((con.type === '=' && a !== b) || (con.type === 'â‰ ' && a === b)) {
                messageDiv.textContent = `Constraint between (${r + 1},${c + 1}) and (${con.r2 + 1},${con.c2 + 1}) is invalid`;
                return;
              }
            }
          }
        }
      }
    }

    function isBalanced(arr) {
      const ones = arr.filter(v => v === 1).length;
      const twos = arr.filter(v => v === 2).length;
      return ones <= SIZE / 2 && twos <= SIZE / 2;
    }

    function hasTriple(arr) {
      for (let i = 0; i < arr.length - 2; i++) {
        if (arr[i] && arr[i] === arr[i + 1] && arr[i] === arr[i + 2]) return true;
      }
      return false;
    }

    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }

    function resetUserEntries() {
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          const cell = table.rows[r].cells[c];
          if (!cell.classList.contains('locked')) {
            board[r][c] = 0;
            cell.textContent = '';
          }
        }
      }
      messageDiv.textContent = '';
    }

    function showRules() {
      const rulesText = `
GAME RULES:

1. Equal Number of Symbols
- Each row and column must contain exactly 3 â—¯ (Circle) and 3 â˜½ (Crescent).
- No more than 3 of either symbol in any row or column.

2. No Three in a Row or Column
- You cannot place three of the same symbols consecutively.
- âœ… Example: â—¯ â˜½ â—¯ â˜½ is valid
- âŒ Example: â˜½ â˜½ â˜½ is invalid

3. Constraints Between Cells
- '=' means both cells must have the same symbol.
- 'â‰ ' means the cells must have different symbols.
- Constraints appear only between adjacent cells, not on the outer edges.

4. Prefilled Cells
- A few cells are filled at the start and cannot be changed.
- These cells are visually locked with gray background.
      `;
      alert(rulesText);
    }
  </script>  

</body>
</html>